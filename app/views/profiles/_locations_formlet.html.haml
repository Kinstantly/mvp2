- formlet = 'locations'

-# Display the locations of the STORED profile.
-# However, if there are none, display a dummy entry to provide a way to activate this formlet.
- display_locations = @profile.errorfree.sorted_locations.presence || [Location.new]
- display_locations.each_with_index do |location, i|
	.location_block{'data-i' => "#{i}"}
		%aside.address.location.editable
			%span.attribute_display{itemprop: 'street-address'}
				- if location.display_address.present?
					%span= location.address1
					%span= location.address2
					%span= location.display_city_region_postal_code
				- else
					%span= profile_blank_attribute_message(Location.human_attribute_name :display_address)
		%aside.telephone.location.editable
			%span.attribute_display{itemprop: 'telephone'}
				- if location.phone.present?
					= location_linked_phone(location)
				- else
					= profile_blank_attribute_message(Location.human_attribute_name :display_phone)
		%aside.information.location.editable
			%span.attribute_display
				= location.note.presence || profile_blank_attribute_message(Location.human_attribute_name :note)
			- if i == 0 && display_locations.size > 1
				= link_to t('views.profile.view.more_locations'), '#', class: 'more'
				= link_to t('views.profile.view.hide_locations'), '#', class: 'less'

- locations = @profile.sorted_locations
- @country ||= (locations.first.try(:country).presence || default_profile_country)
.edit.popover
	= nested_form_for [:formlet_update, @profile], remote: true, html: {id: "edit-#{formlet}"} do |f|
		%h3{class: 'form_section'}= Profile.human_attribute_name :locations
		= f.error_messages
		= hidden_field_tag 'formlet', formlet
		= hidden_field_tag 'reload_map', 't'
		= hidden_field_tag 'refresh_partials', 'payments_setup'
		= f.fields_for :locations, locations do |lf|
			.text_field
				= lf.label :address1
				= lf.text_field :address1
			.text_field
				= lf.label :address2
				= lf.text_field :address2
			.text_field
				= lf.label :city
				= autocomplete_form_field :city, nil, autocomplete_location_city_profiles_path, form_builder: lf
				= lf.label :region
				= lf.subregion_select :region, @country, include_blank: '--'
			.text_field
				= lf.label :postal_code
				= lf.text_field :postal_code
				= lf.hidden_field :country, value: @country
			.text_field
				= lf.label :phone
				= lf.text_field :phone
				%p.note= t 'views.location.edit.phone_example'
			.text_field.location_note_field
				%span.char_count
				= lf.label :note
				= lf.text_field :note
				%p.note= t 'views.location.edit.note_example'
			= lf.link_to_remove t('views.location.edit.remove'), data: { confirm: t('views.location.edit.remove_confirm') }
		= f.link_to_add t('views.location.edit.add'), :locations, class: 'form_section'
		#locations_buttons
			= f.submit t('views.profile.edit.submit'), data: { disable_with: t('views.profile.edit.submit_disable') }, class: 'save'
			= link_to t('views.profile.edit.cancel'), '#', class: 'cancel button'

:coffeescript
	# If we had a validation error, we are redisplaying the formlet and must hide locations that are marked for destruction.
	$('.fields.marked_for_destruction').css('display', 'none')
	
	# Don't activate the pop-over formlet when clicking more/less.
	$('.location.editable a.more, .location.editable a.less').addClass('dont_popover')
	
	$('.location.editable a.more').on 'click', () ->
		clicked = $(this).css 'display', 'none'
		$('a.less', clicked.parent()).css 'display', 'block'
		$('.location_block + .location_block').css 'display', 'block'
		false
		
	$('.location.editable a.less').on 'click', () ->
		clicked = $(this).css 'display', 'none'
		$('a.more', clicked.parent()).css 'display', 'block'
		$('.location_block + .location_block').css 'display', 'none'
		false
	
	setup_note_counter = (field) ->
		field.find('.location_note_field input').simplyCountable({
			counter: field.find('.location_note_field .char_count'),
			maxCount: my_vars.edit_location.max_lengths.note
		})
	
	# Set up counters for fields that are already loaded.
	$('.fields').each -> setup_note_counter $(this)
	
	# Set up counters and autocompletion for any fields that are added after the page loaded.
	$(document).on 'nested:fieldAdded:locations', (event) ->
		setup_note_counter event.field
		configure_autocomplete_form_fields '.autocomplete-form-field', event.field

-# After the partial document is loaded, reload the map with the updated locations list.
- if params[:reload_map].present?
	:javascript
		$(function () {
			my_vars.locations_json	= '#{escape_javascript @profile.sorted_locations.to_json}';
			my_vars.locations_total	=  #{@profile.locations.size};
			my_vars.location_remote_only = #{@profile.consult_remotely ? 'true' : 'false'};
			my_vars.profile_map.init();
		});
