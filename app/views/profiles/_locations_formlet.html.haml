- formlet = 'locations'
- locations = @profile.sorted_locations
- @country ||= (locations.first.try(:country).presence || default_profile_country)
.edit.popover
	= nested_form_for @profile, url: formlet_update_profile_path(@profile), remote: true, html: {id: "edit-#{formlet}"} do |f|
		%h3{class: 'form_section'}= Profile.human_attribute_name :locations
		= f.error_messages
		= hidden_field_tag 'formlet', formlet
		= f.fields_for :locations, locations do |lf|
			.text_field
				= lf.label :address1
				= lf.text_field :address1
			.text_field
				= lf.label :address2
				= lf.text_field :address2
			.text_field
				= lf.label :city
				= autocomplete_form_field :city, nil, autocomplete_location_city_profiles_path, form_builder: lf
				= lf.label :region
				= lf.subregion_select :region, @country, include_blank: '--'
			.text_field
				= lf.label :postal_code
				= lf.text_field :postal_code
				= lf.hidden_field :country, value: @country
			.text_field
				= lf.label :phone
				= lf.text_field :phone
				%p.note= t 'views.location.edit.phone_example'
			.text_field.location_note_field
				%span.char_count
				= lf.label :note
				= lf.text_field :note
				%p.note= t 'views.location.edit.note_example'
			- if current_user.profile_editor?
				.text_field
					= lf.label :search_area_tag_id
					= lf.collection_select :search_area_tag_id, SearchAreaTag.all, :id, :name, {include_blank: t('views.profile.edit.search_area_tag_other')}
			= lf.link_to_remove t('views.location.edit.remove'), confirm: t('views.location.edit.remove_confirm')
		= f.link_to_add t('views.location.edit.add'), :locations, class: 'form_section'
		#locations_buttons
			= f.submit 'Save', disable_with: 'Saving...', class: 'save'
			= link_to 'Cancel', '#', class: 'cancel button'
-# Display the locations of the STORED profile.
-# However, if there are none, display a dummy entry to provide a way to activate this formlet.
- (locations = @profile.errorfree.sorted_locations.presence || [Location.new]).each_index do |i|
	%span{class: "location location_address editable attribute_display#{i > 0 ? ' more' : ''}", itemprop: "street-address"}
		= locations[i].display_address.presence || profile_blank_attribute_message(Location.human_attribute_name :display_address)
	- if i == 0 && locations.size > 1
		%span
			= link_to t('views.profile.view.more_locations'), '#', id: 'more_locations'
			= link_to t('views.profile.view.hide_locations'), '#', id: 'hide_locations'
	%span{class: "location editable attribute_display#{i > 0 ? ' more' : ''}", itemprop: "telephone"}
		= locations[i].display_phone.presence || profile_blank_attribute_message(Location.human_attribute_name :display_phone)
	%span{class: "location location_note editable attribute_display#{i > 0 ? ' more' : ''}"}
		= locations[i].note.presence || profile_blank_attribute_message(Location.human_attribute_name :note)

:coffeescript
	# In case we are re-rendering on an error, make sure locations marked for destruction are not visible.
	$('.fields.marked_for_destruction').css('display', 'none')
	
	$('#more_locations').click () ->
		$(this).css 'display', 'none'
		$('#hide_locations').css 'display', 'inline'
		$('span.location.more').css 'display', 'block'
		false
	
	$('#hide_locations').click () ->
		$(this).css 'display', 'none'
		$('#more_locations').css 'display', 'inline'
		$('span.location.more').css 'display', 'none'
		false
	
	setup_note_counter = (field) ->
		field.find('.location_note_field input').simplyCountable({
			counter: field.find('.location_note_field .char_count'),
			maxCount: my_vars.edit_location.max_lengths.note
		})
	# Set up counters for fields that are already loaded.
	$('.fields').each -> setup_note_counter $(this)
	# Set up counters for any fields that are added after the page loaded.
	$(document).on 'nested:fieldAdded:locations', (event) -> setup_note_counter(event.field)
